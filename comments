01- Basics

Interfaces are needed in order to help implementation of distributed responsibility.
Distribute responsibility over the methods - each method is responsible for some operation.

in groovy package needs to be specified if it is contained in some  module  etc. /scripts  or /pl.training.groovy.bank

def - used to specify variable of a dynamic type - we can change it by assigning a value of different type - e.g. int to string.

if we define a type of variable directly like  String text, variable will maintain the type.

groovy-doc - java-doc , based on the comments we can generate documentation. In order to do it we need to specify in
CLI groovydoc /<class_path> /<directory_to_save_document>


hashCode - state of the object (field values ) is translated into one value - hashCode. It can be used in collections, allowing fast access to the elements in a collection - like index.
especially useful when working on large collections

equals - checks if two Objects are equal based on their state (values). We are not talking about references - we are not checking
if that is the same object.

super - use closest parent method implementation. if we want to inherit a certain method implementation from our preceeder we use - super.super.super<...>

private - field and methods are exclusive for the class where it is implemented

protected - field and its methods are shared amongst the Class and classes which inherit from it

polymorphism - using contracts /interface or abstract class we have different implementations of a method for a certain objects/ classes
contracts help to generalize code.


default methods in interfaces - can be used inside interfaces, default methods if implemented in inheriting class are ignored, if they are not present
then a default method from interface is implemented in an intheriting class.

Aggregation. composition / by setting a new fields using existing types we are using composition/aggregation.
wzorce projektowe w OOP - gang of four


//  Observer design pattern in bank application

we have a list / map in which we keep observers,
we implement three methods which will handle the list - attach, detach, notify (observer)
Observer will implement this method (e.g. bigDeposit).
This is a trait use example.


Generic types :  <> doesn't use specific variable type, e.g. present in Lists

nullpointer exception - reference which points to an nonexisting Object


JDBC - connecting Java Projects with DBs. JDBC JAVA tutorialspoint - > instead of such "big implementations" we can use schema's like in PostgreAccountNumbergenerator

Instead of using null - use Optional for fields which might not exist, not be present

factory method - > abstract factory

factory method

Product Accounts
ConcreteProduct PostgreLogger / logger,

Creator AccountsFactory interface
Concrete creator - Test/Production Factory


Abstract factory :
n abstract products - abstract factory which creates a whole family of products for a certain client

Unit tests - must be isolated from each other , fast and oriented on a particular method functionality

mockito - library which helps to imitate certain objects, and then run tests on it.
http://site.mockito.org/

spock

TODO :
RetroLambda
Kotlin


sourcemaking.com - design patterns, examples

git flow , git flow sciagawka
